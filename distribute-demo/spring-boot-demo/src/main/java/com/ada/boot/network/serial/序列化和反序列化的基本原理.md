# 序列化的本质
序列化是把对象的状态信息转化为可存储或传输的形式过程，也就是把对象转化为字节序列
的过程称为对象的序列化

反序列化是序列化的逆向过程，把字节数组反序列化为对象，把字节序列恢复为对象的过程
成为对象的反序列化

# Transient  关键字
Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变
量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是
0，对象型的是 null

# Java  序列化的一些简 单总结
1. Java 序列化只是针对对象的状态进行保存，至于对象中的方法，序列化不关心
2. 当一个父类实现了序列化，那么子类会自动实现序列化，不需要显示实现序列化接口
3. 当一个对象的实例变量引用了其他对象，序列化这个对象的时候会自动把引用的对象也进
   行序列化（实现深度克隆）
4. 当某个字段被申明为 transient 后，默认的序列化机制会忽略这个字段
5. 被申明为 transient 的字段，如果需要序列化，可以添加两个私有方法：writeObject 和
   readObject

# 简单了解各种序列化技术
##  XML 序列化框架介绍
XML 序列化的好处在于可读性好，方便阅读和调试。但是序列化以后的字节码文件比较大，
而且效率不高，适用于对性能不高，而且 QPS 较低的企业级内部系统之间的数据交换的场景，
同时 XML 又具有语言无关性，所以还可以用于异构系统之间的数据交换和协议。比如我们熟
知的 Webservice，就是采用 XML 格式对数据进行序列化的。XML 序列化/反序列化的实现方
式有很多，熟知的方式有 XStream 和 Java 自带的 XML 序列化和反序列化两种
## JSON 序列化框架
JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，相对于 XML 来说，JSON
的字节流更小，而且可读性也非常好。现在 JSON 数据格式在企业运用是最普遍的
JSON 序列化常用的开源工具有很多
1. Jackson （https://github.com/FasterXML/jackson）
2. 阿里开源的 FastJson （https://github.com/alibaba/fastjon）
3. Google 的 GSON (https://github.com/google/gson)
   这几种 json 序列化工具中，Jackson 与 fastjson 要比 GSON 的性能要好，但是 Jackson、
   GSON 的稳定性要比 Fastjson 好。而 fastjson 的优势在于提供的 api 非常容易使用
   Hessian 序列化框架
   Hessian 是一个支持跨语言传输的二进制序列化协议，相对于 Java 默认的序列化机制来说，
   Hessian 具有更好的性能和易用性，而且支持多种不同的语言
   实际上 Dubbo 采用的就是 Hessian 序列化来实现，只不过 Dubbo 对 Hessian 进行了重构，
   性能更高
##  Avro 序列化
   Avro 是一个数据序列化系统，设计用于支持大批量数据交换的应用。它的主要特点有：支持
   二进制序列化方式，可以便捷，快速地处理大量数据；动态语言友好，Avro 提供的机制使动
   态语言可以方便地处理 Avro 数据。
## kyro 序列化框架                                           
   Kryo 是一种非常成熟的序列化实现，已经在 Hive、Storm）中使用得比较广泛，不过它不能
   跨语言. 目前 dubbo 已经在 2.6 版本支持 kyro 的序列化机制。它的性能要优于之前的
   hessian2
##  Protobuf 序列化框架
   Protobuf 是 Google 的一种数据交换格式，它独立于语言、独立于平台。Google 提供了多种
   语言来实现，比如 Java、C、Go、Python，每一种实现都包含了相应语言的编译器和库文件，
   Protobuf 是一个纯粹的表示层协议，可以和各种传输层协议一起使用。
   Protobuf 使用比较广泛，主要是空间开销小和性能比较好，非常适合用于公司内部对性能要
   求高的 RPC 调用。 另外由于解析性能比较高，序列化以后数据量相对较少，所以也可以应
   用在对象的持久化场景中
   但是要使用 Protobuf 会相对来说麻烦些，因为他有自己的语法，有自己的编译器，如果需要
   用到的话必须要去投入成本在这个技术的学习中
   protobuf 有个缺点就是要传输的每一个类的结构都要生成对应的 proto 文件，如果某个类发
   生修改，还得重新生成该类对应的 proto 文件