# 单体架构到微服务架构的带来的变化

RestTemplate
服务于服务之间，一定不是相互隔离的，而是必须要相互联系进行数据通信才能实现完整的功能。所以在刚刚的案例中，我们拆分出来的服务使用 RestTemplate 来进行远程通信。

在了解 RestTemplate 之前，先来简单了解下 HTTP Client，我们实现对于 http 服务的远程调用，常见的手段是基于 Apache 提供的 HttpClient，或者是 Square 公司开源的 OkHttp。还有 Netflix 公司提供的 Feign（feign 大家都比较熟悉，基于 spring cloud 开发的常见组件，可以使得我们用面向接口的编程来实现远程调用）等等.

简单来说，RestTemplate 是 Spring 提供的用来访问 REST 服务的客户端，以前我们使用Apache HttpClient 来进行远程调用时，需要写非常多的代码，还需要考虑各种资源回收的问题。而 RestTemplate 简化了 Http 服务的通信，我们只需要提供 URL，RestTemplate 会帮我们搞定一切。

另外，需要注意的是，RestTemplate 并没有重复造轮子，而是利用了现有的技术，如 JDK 或
Apache HttpClient 、OkHttp 等来实现 http 远程调用

# 重新认识 Zookeeper

## Zookeeper  的前世今生

Apache ZooKeeper 是一个高可靠的**分布式协调中间件**。它是 Google Chubby 的一个开源实现，那么它主要是解决什么问题的呢？那就得先了解 Google Chubby

Google Chubby 是谷歌的一个用来解决分布式一致性问题的组件，同时，也是粗粒度的分布式锁服务

## 分布式一致性问题

什么是分布式一致性问题呢？

简单来说，就是在一个分布式系统中，有多个节点，每个节点都会提出一个请求，但是在所有节点中只能确定一个请求被通过。而这个通过是需要所有节点达成一致的结果，所以所谓的一致性就是在提出的所有请求中能够选出最终一个确定请求。并且这个请求选出来以后，所有的节点都要知道。

这个就是典型的拜占庭将军问题
拜占庭将军问题说的是：
拜占庭帝国军队的将军们必须通过投票达成一致来决定是否对某一个国家发起进攻。但是这些将军在地里位置上是分开的，并且在将军中存在叛徒。叛徒可以通过任意行动来达到自己的目标：

1. 欺骗某些将军采取进攻行动
2. 促使一个不是所有将军都统一的决定，比如将军们本意是不希望进攻，但是叛徒可以促成进攻行动
3. 迷惑将军使得他们无法做出决定如果叛徒达到了任意一个目标，那么这次行动必然失败。只有完全达成一致那么这次进攻才可能胜利

拜占庭问题的本质是，由于网络通信存在不可靠的问题，也就是可能存在消息丢失，或者网络延迟。如何在这样的背景下对某一个请求达成一致。

**解决**
为了解决这个问题，很多人提出了各种协议，比如大名鼎鼎的 Paxos； 也就是说在不可信的网络环境中，按照 paxos 这个协议就能够针对某个提议达成一致。

所以：分布式一致性的本质，就是在分布式系统中，多个节点就某一个提议如何达成一致

➢ 这个和 Google Chubby 有什么关系呢

在 Google 有一个 GFS(google file system)，他们有一个需求就是要从多个 gfs server 中选出一个 master server。这个就是典型的一致性问题，5 个分布在不同节点的 server，需要确定一个 master server，而他们要达成的一致性目标是：确定某一个节点为 master，并且所有节点要同意。
而 GFS 就是使用 chubby 来解决这个问题的。

实现原理是：
所有的 server 通过 Chubby 提供的通信协议到 Chubby server 上创建同一个文件，当然，最终只有一个 server 能够获准创建这个文件，这个 server 就成为了 master，它会在这个文件中写入自己 的地址，这样其它的 server 通过读取这个文件就能知道被选出的master 的地址

## 分布式锁服务

从另外一个层面来看，Chubby 提供了一种粗粒度的分布式锁服务，chubby 是通过创建文件的形式来提供锁的功能，server 向 chubby 中创建文件其实就表示加锁操作，创建文件成功表示抢占到了锁。

由于 Chubby 没有开源，所以雅虎公司基于 chubby 的思想，开发了一个类似的分布式协调组件 Zookeeper，后来捐赠给了 Apache。所以，大家一定要了解，zookeeper 并不是作为注册中心而设计，他是作为分布式锁的一种设计。而注册中心只是他能够实现的一种功能而已

# zookeeper 的设计猜想

基于 Zookeeper 本身的一个设计目标，zookeeper 主要是解决分布式环境下的服务协调问题而产生的，我们来猜想一下，如果我们要去设计一个 zookeeper，需要满足那些功能呢？

（1）防止单点故障
（2）Leader 角色

Leader 服务器是整个 zookeeper 集群的核心，主要的工作任务有两项

a.事物请求的唯一调度和处理者，保证集群事物处理的顺序性
b.集群内部各服务器的调度者
（3）Follower 角色
Follower 角色的主要职责是

a. 处理客户端非事物请求、转发事物请求给 leader 服务器
b. 参与事物请求 Proposal 的投票（需要半数以上服务器通过才能通知 leader commit 数据;
Leader 发起的提案，要求 Follower 投票）
c. 参与 Leader 选举的投票

（4）数据同步

## 分布式事务的数据一致性协议有 2PC 协议和 3PC 协议

关于  2 PC  提交（Two Phase Commitment Protocol）当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的 ACID 特性，就需要引入一个“协调者”（TM）来统一调度所有分布式节点的执行逻辑，这些被调度的分布式节点被称为 AP。TM 负责调度 AP 的行为，并最终决定这些 AP 是否要把事务真正进行提交；因为整个事务是分为两个阶段提交，所以叫 2pc

阶段一：提交事务请求（投票）

1. 事务询问
   协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的
   响应
2. 执行事务
   各个参与者节点执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中，尽量把提交过程中
   所有消耗时间的操作和准备都提前完成确保后面 100%成功提交事务
3. 各个参与者向协调者反馈事务询问的响应
   如果各个参与者成功执行了事务操作，那么就反馈给参与者 yes 的响应，表示事务可以执行；
   如果参与者没有成功执行事务，就反馈给协调者 no 的响应，表示事务不可以执行，上面这个阶
   段有点类似协调者组织各个参与者对一次事务操作的投票表态过程，因此 2pc 协议的第一个阶
   段称为“投票阶段”，即各参与者投票表名是否需要继续执行接下去的事务提交操作。
   
   阶段二：执行事务提交
   在这个阶段，协调者会根据各参与者的反馈情况来决定最终是否可以进行事务提交操作，正常情况
   下包含两种可能:执行事务、中断事务

# Zookeeper 的安装部署

安装zookeeper 有两种运行模式：集群模式和单击模式。
下载 zookeeper 安装包：http://apache.fayea.com/zookeeper/
下载完成，通过 tar -zxvf 解压
常用命令

1. 启动 ZK 服务:
   bin/zkServer.sh start
2. 查看 ZK 服务状态:
   bin/zkServer.sh status
3. 停止 ZK 服务:
   bin/zkServer.sh stop
4. 重启 ZK 服务:
   bin/zkServer.sh restart
5. 连接服务器
   zkCli.sh -timeout 0 -r -server ip:port
   
   单机环境安装
   一般情况下，在开发测试环境，没有这么多资源的情况下，而且也不需要特别好的稳定性的前提下，我们可以使用单机部署；
   初次使用zookeeper，需要将conf目录下的zoo_sample.cfg文件copy一份重命名为zoo.cfg修改 dataDir 目录，dataDir 表示日志文件存放的路径（关于 zoo.cfg 的其他配置信息后面会讲）

