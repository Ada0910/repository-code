# 垃圾回收

首先，要回收垃圾，机器跟人不一样，不知道什么是垃圾，告诉程序什么是垃圾

## 引用计数法

对于某个对象而言，只要应用程序中持有该对象的引用，就说明该对象不是垃圾，如果一个对象没有任
何指针对其引用，它就是垃圾

弊端：如果AB相互持有引用，导致永远不能被回收

## 可达性分析

通过GC ROOT的对象，开始向下寻找，看某个对象是否可达

能作为GC Root:类加载器、Thread、虚拟机栈的本地变量表、static成员、常量引用、本地方法栈的变量等

# 垃圾回收算法

## 标记-清除

- 标记
  找到内存中需要回收的对象，并且把它们标记出来
  此时堆中所有的对象都会被扫描一遍，从而才能确定需要回收的对象，比较耗时
  ![image.png](./assets/1670856392425-image.png)
  
  - 清除
    清除掉被标记需要回收的对象，释放出对应的内存空间
    ![image.png](./assets/1670856435484-image.png)
  
  缺点：
  标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。
  (1)标记和清除两个过程都比较耗时，效率不高
  (2)会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作
  总结：慢，不连续
  
  ## 复制
  
  将内存划分分为两块现代的区域，每次只使用其中一块，如图
  ![image.png](./assets/1670857570541-image.png)
  
  ## 标记-整理

标记过程仍然与"标记-清除"算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活
的对象都向一端移动，然后直接清理掉端边界以外的内存
![image.png](./assets/1670857596159-image.png)
让所有存活的对象都向一端移动，清理掉边界意外的内存
![image.png](./assets/1670857671590-image.png)

# 分代收集算法

Young区：复制算法（对象在被分配之后，可能生命周期比较短，Young区复制效率比较高）
Old区：标记清除或者标记整理（Old区对象存活时间比较长，复制来复制去没必要，不弱做个标记再清理）







